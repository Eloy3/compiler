package front_end.parser;

import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;

import java_cup.runtime.*;

import java.io.PrintStream;
import java.util.HashMap;
import front_end.simbols.*;
import front_end.scanner.*;

class Parser; 

parser code {: 
        private Lexic lexic;

        public Parser(Lexic l, java_cup.runtime.SymbolFactory sf) {
                super(l, sf);
                this.lexic = l;
        }

        public Parser(Lexic l) {
                this(l, new ComplexSymbolFactory());
        }
:}

terminal SUMA, RESTA, MUL, DIV, EParen, DParen, ASSIGN, PUNTICOMA, ENTER, BOOLEA, EClau, DClau, COMA, EClaudator, DClaudator;
terminal String ID, ENT, BOOL, CONST, TUPLA, FUNCIO, RETORNA, BUIT, IGUAL, DIFERENT, OLI, OLO, MENTRE, PER, SI, SINO, PRINCIPAL, SORTIDA, SORTIDALN, ENTRADA;

non terminal tipusbucle;
non terminal NodeExprcomposta exprcomposta;
non terminal NodeOperador_expr operador_expr;
non terminal NodeSentencia sentencia;
non terminal NodeSentencies sentencies;
non terminal NodeSentencies2 sentencies2;
non terminal NodeOperador_cond operador_cond;
non terminal NodeDecl_Variable decl_variable;
non terminal NodeDecl_funcio decl_funcio;
non terminal NodeCrida_funcio crida_funcio;
non terminal NodeTipus tipus;
non terminal NodeTipus tipusf;
non terminal NodeVarinic varinic;
non terminal NodeVarinic2 varinic2;
non terminal NodeExprsimple exprsimple;
non terminal NodeParam param;
non terminal NodeParam2 param2;
non terminal NodeArg arg;
non terminal NodeArg2 arg2;
non terminal NodeBlocf blocf;
non terminal NodeBlocf2 blocf2;
non terminal NodeComportamentv1 comportamentvl;
non terminal NodeBucle bucle;
non terminal NodeSentencia sentenciaf;
non terminal NodeRetorna retorna;
non terminal cons, decl_variable_local;

non terminal NodePrincipal principal;
non terminal NodeCondicional condicional;
non terminal NodeCondsino condsino;
non terminal NodeSino sino;
non terminal NodeCondicio condicio;
non terminal NodePrograma programa;
non terminal NodePmb pmb;
non terminal NodeSortida sortida;
non terminal NodeEntrada entrada;
non terminal NodeLlistaValors llista_valors;
non terminal NodeValor valor;
non terminal NodeCodi codi;
non terminal NodeProcedures procedures;


start with codi;

//programa principal

codi ::= procedures:a principal:b  {: RESULT = new NodeCodi(a,b);:};

procedures ::= decl_funcio:a procedures:b {: RESULT = new NodeProcedures(a,b);:}
                | {: RESULT = new NodeProcedures();:};

principal::=  programa PRINCIPAL EParen DParen pmb EClau sentencies:s DClau {: RESULT = new NodePrincipal(s);:};

programa ::= {: RESULT = new NodePrograma(); :};

pmb ::= {:RESULT = new NodePmb();:};

//sentencies

sentencies ::=   sentencia:s sentencies2:s2 {: RESULT = new NodeSentencies(s,s2);:};

sentencies2 ::= sentencies:s {: RESULT = new NodeSentencies2(s);:} 
                | {: RESULT = new NodeSentencies2();:};

sentencia ::= cons decl_variable:v PUNTICOMA {: RESULT = new NodeSentencia(v,"decl_variable"); :}
              | varinic2:v PUNTICOMA {: RESULT = new NodeSentencia(v,"varinic2"); :}
              | bucle:b {: RESULT = new NodeSentencia(b,"bucle"); :}
              | condicional:c {: RESULT = new NodeSentencia(c,"condicional"); :}
              | decl_funcio:df {: RESULT = new NodeSentencia(df,"decl_funcio"); :}
              | crida_funcio:cf PUNTICOMA{: RESULT = new NodeSentencia(cf,"crida_funcio"); :}
              | sortida:s PUNTICOMA {:RESULT = new NodeSentencia(s,"sortida"); :}
              | entrada:e PUNTICOMA {:RESULT = new NodeSentencia(e,"entrada"); :};      

crida_funcio ::= ID:name EParen arg:a DParen {: RESULT = new NodeCrida_funcio(name, a, lexic.getLineColumn()); :};

arg ::= ID:id arg2:a2 {: RESULT = new NodeArg(id, a2); :}
            |   {: RESULT = new NodeArg(); :};

arg2 ::= COMA arg:a {: RESULT = new NodeArg2(a); :}
            |   {: RESULT = new NodeArg2(); :};

decl_funcio ::= FUNCIO tipusf:t ID:name EParen param:p DParen EClau blocf:b DClau {: RESULT = new NodeDecl_funcio(t,name,p,b, lexic.getLineColumn()); :};

param ::= tipus:t ID:id param2:p2 {: RESULT = new NodeParam(t, id, p2); :}
            |   {: RESULT = new NodeParam(); :};

param2 ::= COMA param:p {: RESULT = new NodeParam2(p); :}
            |   {: RESULT = new NodeParam2(); :};

cons ::= CONST
        |     ;

exprsimple ::= ID:v             {: RESULT = new NodeExprsimple(NodeExprsimple.exprsimple.id, v); :}
             | ENTER:v          {: RESULT = new NodeExprsimple(NodeExprsimple.exprsimple.enter, v.toString()); :}
             | BOOLEA:v         {: RESULT = new NodeExprsimple(NodeExprsimple.exprsimple.boolea, v.toString()); :}
             | crida_funcio:a   {: RESULT = new NodeExprsimple(a); :};

tipus ::= ENT   {: RESULT = new NodeTipus(Tipus.ENT); :}
        | BOOL  {: RESULT = new NodeTipus(Tipus.BOOL); :};

tipusf ::= ENT {: RESULT = new NodeTipus(Tipus.ENT); :}
        | BOOL {: RESULT = new NodeTipus(Tipus.BOOL); :}
        | BUIT {: RESULT = new NodeTipus(Tipus.BUIT); :};

blocf ::= sentenciaf:s blocf2:b  {: RESULT = new NodeBlocf(s,b); :};

blocf2 ::= blocf:a {: RESULT = new NodeBlocf2(a); :}
         | {: RESULT = new NodeBlocf2(); :};

//El mateix que sentencia per√≤ sense declaracions de funcions.

sentenciaf ::= cons decl_variable:v PUNTICOMA {: RESULT = new NodeSentencia(v,"decl_variable"); :}
              | varinic2:v PUNTICOMA {: RESULT = new NodeSentencia(v,"varinic2"); :}
              | bucle:b {: RESULT = new NodeSentencia(b,"bucle"); :}
              | condicional:c {: RESULT = new NodeSentencia(c,"condicional"); :}
              | retorna:r {: RESULT = new NodeSentencia(r,"retorna"); :}
              | sortida:s PUNTICOMA {:RESULT = new NodeSentencia(s, "sortida"); :}
              | entrada:e PUNTICOMA {:RESULT = new NodeSentencia(e, "entrada"); :};     

retorna ::= RETORNA exprsimple:expr PUNTICOMA {: RESULT = new NodeRetorna(expr, lexic.getLineColumn()); :}
        |   RETORNA PUNTICOMA {: RESULT = new NodeRetorna(); :};

decl_variable ::= tipus:t ID:id varinic:vi {: RESULT = new NodeDecl_Variable(t, id, vi, lexic.getLineColumn()); :};

varinic ::= ASSIGN exprsimple:v   {: RESULT = new NodeVarinic(v); :}
            |      {: RESULT = new NodeVarinic(); :}           ;

varinic2 ::= ID:v ASSIGN exprsimple:v1 {: RESULT = new NodeVarinic2(v, v1, lexic.getLineColumn()); :}
        | ID:v ASSIGN exprcomposta:e {: RESULT = new NodeVarinic2(v, e, lexic.getLineColumn()); :};

exprcomposta ::= exprsimple:a operador_expr:o exprsimple:b {: RESULT = new NodeExprcomposta(a,o,b,lexic.getLineColumn());:};

operador_expr ::= SUMA:a {: RESULT = new NodeOperador_expr(a.toString());:}
                | RESTA:a {: RESULT = new NodeOperador_expr(a.toString());:}
                | MUL:a {: RESULT = new NodeOperador_expr(a.toString());:}
                | DIV:a {: RESULT = new NodeOperador_expr(a.toString());:};

// **** Sortida per pantalla ****

sortida ::= SORTIDA EParen llista_valors:v DParen {: RESULT = new NodeSortida(v,false,lexic.getLineColumn());:}
        | SORTIDALN EParen llista_valors:v DParen {: RESULT = new NodeSortida(v,true,lexic.getLineColumn());:};

llista_valors ::= valor:v {: RESULT = new NodeLlistaValors(v);:}|
                  valor:v COMA llista_valors:lv {: RESULT = new NodeLlistaValors(v, lv);:} ;

valor ::= ID:v {: RESULT = new NodeValor(NodeValor.exprsimple.id, v); :}
         | ENTER:v {: RESULT = new NodeValor(NodeValor.exprsimple.enter, v.toString()); :}
         | BOOLEA:v {: RESULT = new NodeValor(NodeValor.exprsimple.boolea, v.toString()); :};

// **** Entrada per teclat ****

entrada ::= ENTRADA EParen ID:i DParen {: RESULT = new NodeEntrada(i);:};

// **** IF ****

condicional ::= SI EParen condicio:a DParen EClau blocf:b DClau condsino:c {: RESULT = new NodeCondicional(a,b,c); :};

condicio ::= exprsimple:v operador_cond:o exprsimple:v1 {: RESULT = new NodeCondicio(v,o,v1); :}
                | ID:id {: RESULT = new NodeCondicio(id); :};

condsino ::= SINO EClau blocf:a DClau {: RESULT = new NodeCondsino(a); :}
        |       {: RESULT = new NodeCondsino(); :};

operador_cond ::= OLI:a {: RESULT = new NodeOperador_cond(a); :}
        | OLO:a {: RESULT = new NodeOperador_cond(a); :}
        | IGUAL:a {: RESULT = new NodeOperador_cond(a); :}
        | DIFERENT:a {: RESULT = new NodeOperador_cond(a); :};


// **** WHILE i FOR ****

bucle ::= MENTRE EParen condicio:c DParen EClau blocf:bloc DClau {: RESULT = new NodeBucle(c,bloc,lexic.getLineColumn()); :}

        | PER EParen decl_variable:decl PUNTICOMA condicio:cond PUNTICOMA comportamentvl:comp DParen EClau blocf:bloc DClau {: RESULT = new NodeBucle(decl,cond,comp,bloc,lexic.getLineColumn()); :};


comportamentvl ::= ID:v SUMA SUMA {: RESULT = new NodeComportamentv1(v, Comportament.INCREMENT, lexic.getLineColumn()); :}
                | ID:v RESTA RESTA {: RESULT = new NodeComportamentv1(v, Comportament.DECREMENT, lexic.getLineColumn()); :}
                | {: RESULT = new NodeComportamentv1(); :};



